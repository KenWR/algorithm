### 풀이과정

19 * 19 의 이중배열로 오목판이 주어지고   
각 배열의 요소에 0 == 없음 1 == 흑 2 == 백의 형태로   
값이 주어지는게 입력값이다.   

오목판을 생성해 입력값들로 채워주고, 
오목판을 완전탐색하면서 돌을 발견할때마다 8방향으로   
쭉 5번 퍼져나가는데 반대편까지 살펴봐야한다.   
그렇게 길이를 구해 해당 길이가 5가 된다면,   
오목으로 판단하고 가장 왼쪽위에 있는 돌의 좌표를   
구해서 출력하면 되겠다.   

애초에 탐색을 왼쪽 위부터 진행하기에   
지나간 부분을 확인할 필요가 없다고 판단하여   
오른쪽부터 아래 대각 왼쪽부분까지 아래 4방향만 탐색하기로했다.   

```
보드판을 채워 넣고,   

해당 보드판을 행, 열의 순서로 탐색을 진행하다가,   
돌을 발견하면 해당돌이 오목인지 확인한다.  

오목을 찾으면 출력   
```

처음에 이렇게 하려고 했었다.   

```
보드판을 채워 넣고,   

해당 보드판을 행, 열의 순서로 탐색을 진행하다가,   
돌을 발견하면 DFS/BFS 를 진행한다.   

오목을 찾으면 출력
```

그런데 이 방법은 흑돌만, 백돌만 찾을 필요가 없을 뿐더러,   
첫번째 방법은 애초에 왼쪽위부터 탐색하기에 추가적인 코드가 필요 없지만,     
두번째 방법은 왼쪽위의 돌을 출력하기위한 코드가 더 필요해지고,   
코드가 더 복잡해질 우려가 있기 때문에,   
문제가 요하는 brute force 의 취지에 맞게,   
그리고 조금더 가독성있게 첫번째 방법을 이용하기로했다.   

#### 시간 계산

`(19 * 19)` * `(25 * 4)` 로    
`완전탐색할 오목판 전체 크기`와 `대각선을 포함한 오목 방향`을   
보수적으로 구해 4000번이 되겠다.

```c++
void    set_board() {
    입력값을 보드 배열에 넣기
}

void    search_all() {
    완전탐색으로 보드판 전부 흝기
    돌 발견하면 좌표와 돌 색을 매개변수로
    if (find_omok(y, x, 색) == ture) { // 오목이 맞으면
        std::cout << 색 << y << x;
        return
    }
}

bool    find_omok(int y, int x, int color) {
    int len = 0;

    / 를 구하는 함수
    \ 를 구하는 함수
    - 를 구하는 함수
    | 를 구하는 함수

    각 함수중에 return 값 == 5 면 return (true);
}
```
