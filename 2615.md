### 풀이과정

19 * 19 의 이중배열로 오목판이 주어지고   
각 배열의 요소에 0 == 없음 1 == 흑 2 == 백의 형태로   
값이 주어지는게 입력값이다.   

오목판을 생성해 입력값들로 채워주고, 
오목판을 완전탐색하면서 돌을 발견할때마다 8방향으로   
쭉 5번 퍼져나가는데 반대편까지 살펴봐야한다.   
그렇게 길이를 구해 해당 길이가 5가 된다면,   
오목으로 판단하고 가장 왼쪽위에 있는 돌의 좌표를   
구해서 출력하면 되겠다.   

애초에 탐색을 왼쪽 위부터 진행하기에   
지나간 부분을 확인할 필요가 없다고 판단하여   
오른쪽부터 아래 대각 왼쪽부분까지 아래 4방향만 탐색하기로했다.   

```
보드판을 채워 넣고,   

해당 보드판을 행, 열의 순서로 탐색을 진행하다가,   
돌을 발견하면 해당돌이 오목인지 확인한다.  

오목을 찾으면 출력   
```

#### 오류 1

6목인데 만약 2번째 줄부터 시작을 해버리면   
오목이 나와버리는 문제가 발생했다.   

### 문제풀이 2

위의 문제풀이 1에서 오목을 탐색하는 부분을 다르게 진행했다.   
오목을 찾을때 양쪽 반대편을 탐색하도록 했으며   
탐색했을시 (/ \ - |) 4방향으로 나뉘어 탐색을 진행하고   
각 방향에서 매개변수로주어진 돌의 색과 다르면 반복을 종료했다.   
그렇게 돌의 길이를 계산하여 오목임을 확인하면   
또 다시 오목의 왼쪽, 수직의 경우 위쪽을 찾기위해 탐색하는   
오목의 머리를 구하는 함수를 작성하여 머리부분을 출력한다.   

#### 시간 계산

`(19 * 19)` * `(25 * 4)` 로    
`완전탐색할 오목판 전체 크기`와 `대각선을 포함한 오목 방향`을   
보수적으로 구해 4000번이 되겠다.

```c++
void    set_board() {
    입력값을 보드 배열에 넣기
}

void    search_all() {
    완전탐색으로 보드판 전부 흝기
    돌 발견하면 좌표와 돌 색을 매개변수로
    if (오목찾기(y, x, 색)) { // 오목이 맞으면
        오목_머리구하기 (y, x, 색, 오목찾기(y, x, 색))
        return;
    }
}

int    find_omok(int y, int x, int color) {
    int len = 0;

    if (/ 를 구하는 함수 == 5)
        return 1
        .
        .
        .
    \ 를 구하는 함수
        return 2
    - 를 구하는 함수
        return 3
    | 를 구하는 함수
        return 4

    return 0;
}

void    오목_머리구하기(int y, int x, int color, int flag) {
    flag에 맞게 오목 머리 구하고
    color\n 오목 머리의 y, x 좌표 + 1씩해서 출력
}
```
