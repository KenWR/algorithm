문제 이분탐색을하라고? 몰겠다...

vector pair<int, int> animals; // 동물 좌표
vector <int> lanes; // 사대

pair<int, int> animal;를 매번 받아서 저장해 준다.
int lane; // 도 저장

M, N, L; 사대, 동물, 사정거리 를 받는다.
동물개수를 왜 받았을까? 내가 생각했던 로직에서는 필요없었다.

내가 생각한 로직은 모든 발사대로부터 최대거리에서 양측 좌표를 (-1, -1) 하면서 이중배열에 나오는 모든 좌표를 저장하고
그중 가장 y좌표가 최고로 높은 곳이 최전방 lane이 된다. 
최전방 lane을 만들고 각 좌표별로 size_t animals[x 좌표] 를 정렬한 값들을 기준으로 0이 나오거나 
최전방 lane의 y 좌표보다 작은것들을 모두 모아서 최종 동물 수로 출력하려고했다.

이분탐색을하려면 무엇을 기준으로 잡고 탐색을 해야하는가!
문제에 답이있었다!

동물좌표 (a, b) 와 사대(x)로부터의 사거리 계산은
|a - x| + b 이다
그렇다면 동물좌표 a 기준으로 정렬하고 맞으면 삭제 틀리면 냅두기 뭐 이런식인가..

모르겠어서 글들을 찾아보니 와우... 나는 사수들로 동물들을 찾으려했는데 동물들로 부터 사수가 거리내에 존재하는지를 찾아버린다...
있으면 count + 1을 한다.
abs(a - x) + b에서
abs(a - lanes[i]) + b <= L (사거리내에 존재함) 로 찾으면 되겠다.
해당 사수가 존재하는지를 이분탐색으로 찾는거다.

lanes[] 인덱스 번호를 기준으로 두고
각 동물좌표와 거리를 계산을해서 L 값보다 작거나 같으면 answer++
그렇다면 
각 동물좌표에대한 반복문 {
    각 사냥꾼 좌표에대한 이분탐색 {
        인덱스번호 기준으로 찾는다...
        L 값보다 작거나 같은걸 못찾으면 아무것도 하지않고
        찾으면 answer 를 올린다.
    }
}