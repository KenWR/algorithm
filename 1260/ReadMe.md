# 사용언어
C++

# **문제**
그래프를 DFS로 탐색한 결과와 BFS로 탐색한 결과를 출력하는 프로그램을 작성하시오. 

단, 방문할 수 있는 정점이 여러 개인 경우에는 정점 번호가 작은 것을 먼저 방문하고, 더 이상 방문할 수 있는 점이 없는 경우 종료한다. 

정점 번호는 1번부터 N번까지이다.
*입력*
-
첫째 줄에 정점의 개수 N(1 ≤ N ≤ 1,000), 간선의 개수 M(1 ≤ M ≤ 10,000), 탐색을 시작할 정점의 번호 V가 주어진다. 

다음 M개의 줄에는 간선이 연결하는 두 정점의 번호가 주어진다. 

어떤 두 정점 사이에 여러 개의 간선이 있을 수 있다. 

입력으로 주어지는 간선은 양방향이다.


*출력*
-
첫째 줄에 DFS를 수행한 결과를, 그 다음 줄에는 BFS를 수행한 결과를 출력한다. 

V부터 방문된 점을 순서대로 출력하면 된다.


해석 및 접근 방식
-
정점의 개수, 간선의 개수, 탐색을 시작할 정점의 번호 V

그리고 간선의 개수만큼 해당 양방향 간선들이 주어진다.

그림으로 그래프로 그리면 이해하기 수월할 것이다.

하지만 우리가 그린 그래프를 어떻게 컴퓨터가 이해하겠는가.

방법은 아주 간단하다.

각 간선은 양방향이고 서로 중복되는 (1, 2)나 (2, 1) 과 같은 상황은 없기에 

첫번째 인수를 **Array**(배열) 혹은 **List**(리스트) 의 인덱스로 잡고 

두번째 인수를 해당 노드의 인접 노드라고 판단하고 **Array**이나 **List**에 담으면 되겠다.

**List** 보다는 **Array** 로 구현하면 편할것같다.

**Array** 를 사용하고자 한다면 인수를 뒤집어서 추가로 넣으면 될 것이다.

그리고 입력이 1 부터 들어오기때문에 배열을 한칸씩 추가로 늘려야하지만 그냥 애초에 -1 로 들어오게하고 출력할때 +1 로 되도록 했다.

그리고 배열을 최대치로 설정했기에 만약 dfs를 사용했을때 전부 찾고도 끝까지 돌게되면 엄청난 손해가 생기므로

받은 최대 인수의 값을 지정해두고 해당 인수만큼 돌게 하거나 노드를 다 찾으면 끝내도록 종료조건을 두어야겠다.

쓰다보니 후자가 낫다는 판단이 세워졌다.

# **풀이**

맞은 코드
-
```c++
code
```


사용 알고리즘 및 자료구조
-




참고 자료
-




출력 및 예시
-


시간 복잡도와 효율
-


# **오답노트**



틀린 코드
-


리팩토링
-



```c++
code
```

시간복잡도와 효율
-

