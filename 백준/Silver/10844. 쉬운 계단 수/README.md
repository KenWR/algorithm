
1. [문제](#silver-i-쉬운-계단-수---10844)
2. [입 & 출력](#입력)
3. [분석](#분석)
4. [풀이](#풀이)
    1. [의사코드](#의사코드-1)
    2. [시간복잡도](#시간-복잡도)   
5. [오류 수정](#오류-수정)  
    1. [의사코드](#의사코드-2)   
    2. [시간복잡도](#시간-복잡도--2)   
6. [사용 알고리즘](#사용-알고리즘)

# [Silver I] 쉬운 계단 수 - 10844 

[문제 링크](https://www.acmicpc.net/problem/10844) 

### 성능 요약

메모리: 2028 KB, 시간: 0 ms

### 분류

다이나믹 프로그래밍

### 제출 일자

2023년 12월 24일 16:35:43

### 문제 설명

<p>45656이란 수를 보자.</p>

<p>이 수는 인접한 모든 자리의 차이가 1이다. 이런 수를 계단 수라고 한다.</p>

<p>N이 주어질 때, 길이가 N인 계단 수가 총 몇 개 있는지 구해보자. 0으로 시작하는 수는 계단수가 아니다.</p>

### [입력]

 <p>첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 100보다 작거나 같은 자연수이다.</p>

### 출력 

 <p>첫째 줄에 정답을 1,000,000,000으로 나눈 나머지를 출력한다.</p>


### 입력 예시
1
```
1
```
2 
```
2
```
### 출력 예시
1 
```
9
```
2 
```
17
```
### [분석]

주어진 `자릿수` 안에서 존재하는    
각 자릿 수의 차이가 1 인 `계단 수`를 모두 구하라.   

0은 첫번째 자릿수에 들어오지 못한다.   

### [풀이]

2 자릿수가 주어진다면
```
12, 21
23, 32
34, 43
45, 54
56, 65
67, 76
78, 87
89, 98
10
```
로 총 17개가 되겠다.   
그렇게 최대값인 100 자릿수가 들어온다면?   
그 단위는... 모른다.   

0이 100개인 단위는 구골이라고하고   
우리가 아는 1조는 0이 12개 라고한다.   
평범한 연산으로는 구하지 않는편이 좋다.   

어떻게 구해야할까?   
계단 수를 구하는 과정을 TREE 구조로 보면 쉽다.   
레벨 == 자릿수 로 보고
그 연산을 1 ~ 9까지만 하면 계단 수를 구할 수 있다!   

좀더 알아 듣기 쉽게 도식화를 해보자

입력값으로 3을 받았을때
1부터 시작하는 계단 수를 구한다면 
```
       1            - 1레벨 
    /     \       
   0       2        - 2레벨
 /        / \
1        1   3      - 3레벨
```
로 101, 121, 123을 구할 수 있다.   
(n - 1), (n + 1) 로 연산이 이어지는걸 보니   
피보나치가 생각나는 연산법이다.   

해당 부분을 재귀로 풀어보자!
도중에 0이 되어도 좋으나 음수인경우 함수를 종료하고   
각 매개변수와 자릿수를 기준으로 하여   
메모리에 가짓수를 저장하면 되겠다.
arr[y][x] 으로 y축은 1 ~ 9 가짓수 x축은 레벨로
arr[10][105] 가 되겠다.
(0은 계산하지 않으나 가독성 위해 9 -> 10으로 골랐다.)

#### [의사코드 1]
메인함수
1. 메모리에 원하는 계단수가 저장이 안되어있는 경우   
    N값과 시작를 매개변수로 재귀함수를 호출한다.  

재귀함수는 다음과 같다.   

1. 시작 숫자가 기준을 넘어서면 종료
2. 현재 메모리에 (시작 - 1, 자릿수 - 1) +    
    (시작 + 1, 자릿수 - 1) 한 값을 넣는다.   
3. 메모리에 (시작 - 1, 자릿수 - 1)나   
    (시작 + 1, 자릿수 - 1) 가 존재하지 않으면   
    해당 값을 매개변수로 재귀호출한다.
```c++
int main() {
    int N;
    size_t 계단수;
    for (int i = 1; i < 10; i++) {
        if (계단[i][N] == 0)
            재귀함수(i, N);
        계단수 += 계단[i][N];
    }  
    출력 (계단수 % 1,000,000,000);
}

void    재귀함수(int 시작, int 자릿수) {
    if (시작 < 0 || 시작 > 9 || 자릿수 == 0)
        return ;
    if (계단[시작 - 1][자릿수 - 1] == 0)
        재귀함수(시작 - 1, 자릿수 - 1);
    if (계단[시작 + 1][자릿수 - 1] == 0)
        재귀함수(시작 + 1, 자릿수 - 1);
    계단[시작][자릿수] = [시작 - 1][자릿수 - 1] \
    + [시작 + 1][자릿수 - 1]
}
```
#### [시간 복잡도]

Ω(1.6n) 에서 Θ(n) 이 된다.

### [오류 수정]

<details>
    <summary>틀린코드</summary>

```c++
#include <iostream>
#include <vector>
using namespace std;

size_t	계단[10][105];
void	dynamic_p(int start, int digit);

int	main() {
    int N;
    size_t stair_num = 0;
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);

	cin >> N;
	for (int i = 0; i < 10; i++) {
		계단[i][1] = 1;
	}
    for (int i = 1; i < 10; i++) {
        if (계단[i][N] == 0)
            dynamic_p(i, N);
        stair_num = stair_num + 계단[i][N];
	}
    cout << stair_num  % 1000000000;
}

void    dynamic_p(int start, int digit) {
    if (start < 0 || start > 9 || digit < 0)
        return ;
    if (계단[start - 1][digit - 1] == 0)
        dynamic_p(start - 1, digit - 1);
    if (계단[start + 1][digit - 1] == 0)
        dynamic_p(start + 1, digit - 1);
    계단[start][digit] = 계단[start - 1][digit - 1] + 계단[start + 1][digit - 1];
}
```

</details>

높은 수 (15 이상)을 입력값으로 받으면 값이 일정치않게 나온다.   
stack overflow를 의심이 되기에 해당 부분을   
메모이제이션 대신해서
타뷸레이션을 이용해 풀기로 했다.  

타뷸레이션은 역순으로 타고들어가는 재귀와는 다른   
반복문으로 풀어야 하기에 애초에 값을 미리 구해 놓고   
계산을 해서 초반에는 초기화에 오버헤드가 있으나   
후에는 중복계산을 피할 수 있다는 점에서    
최적화가 이루어질 수 있다.   

자릿수가 1이될때까지 타고들어가던 재귀와는 달리   
1자릿수의 시작숫자부터 계산해서 바로 위의 2자릿수까지 구해가며   
자릿수를 N값까지 각 자릿수에 시작숫자의 가짓수를 구해서 저장하고   
나중에 배열에 저장된 N자릿수의 1~9로 시작되는 가짓수를   
더해서 출력하면 되겠다.   

#### [의사코드 2]
1. 이차원 배열을 arr[105][11]로 선언한다.   
    ([N값][1~9]로 조금 넉넉하게 배치한다.)   
2. 우선 0~1 까지 자릿수가 1인 배열의 요소에 1씩 대입한다.   
3. 자릿수를 2부터 시작해 N과 같아질 때까지   
    0부터 시작해 9 까지 순회하며
    `arr[자릿수][1~9] = arr[자릿수][1~9 + 1] + arr[자릿수][1~9 - 1]`
    로 연산을 해준다.
4. 이차원 배열의 y값을 N으로 고정하고   
    1~9 까지 순회하여 각 요소들을 더해주고 출력한다.

```c++
    1자릿수에서 0~9 까지
        계단[1자릿수][0~9] = 1;

    2자릿수부터 N자릿수 까지 { 
        0~9까지 {
            만약 j - 1 이 영보다 크거나 같을동안에는
                계단[자릿수][0~9] += 계단[자릿수 - 1][0~9 - 1];
            만약 j + 1 이 10보다 작을동안에는 
                계단[자릿수][0~9] += 계단[자릿수 - 1][0~9 + 1];
            계단[자릿수][0~9] %= 1000000000;
        }
    }
    1~9까지 N자릿수에 해당하는 요소들을 모두 순회하며 
        각 요소들을 한 변수에 담고
    출력
```

#### [시간 복잡도 -2]

O(N)

### [사용 알고리즘]

Dynamic programming
    Tabulation

### [후기]

문제를 푸는데 있어 오버플로우가 굉장히 많이 일어났다.   
어느부분에서 오버플로우가 일어나질 그래도 어느정도는   
예측하며 코드를 써 내려갔지만 어김없이 오버플로우가 일어나니   
매우 당황스러웠다.   
입력값이 5까지 들어왔을때는 수작업으로 확인해가며   
답이 맞는것을 확인 했으나 입력값이 90이 넘어가버리면   
갑자기 오버플로우가 일어나 답을 틀리게 되었는데   
해당 부분을 찾느라 꽤나 애먹었다.   

틀린이유로는 다음과 같은데   

각 자릿수마다 계산을 하면서 나중가서 그 값이    
컴퓨터가 감당할 수 없는 크기로 커지게되는데   
그렇기에 미리 나머지 연산을 통해 미리 값을   
줄이며 더했어야 하는 부분을 놓쳐서 틀리게 되었다.

결국 반례들을 확인해가며 틀린 이유를 찾고 풀었으나   
나머지 연산이 뒤의 나머지연산에 문제가 되지 않는다는   
그런 단순한 생각을 못해서 생긴 문제인것 같다.   
~(사실 나머지 연산에 내가 모르는 무언가 있지 않을까~   
~하는 그런 생각이 들어서 도중에 연산을 안했었다.)~   
사소한 부분에서도 조금 확실히하는게 좋을것 같다.   

풀면서 난생 처음보는 방식이기도하고   
꽤나 흥미있게 다가오는 풀이 방식이었다.   
개인적으로 최적화라는 부분을 매우 좋아하는데   
이러한 방식으로 최적화를 이룰 수 있다는 것이   
정말 참신하고 재미있게 다가왔다.   
푸는데 조금 힘들었지만 이 배움은 매우 오래갈것 같다.   