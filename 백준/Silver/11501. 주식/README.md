# [Silver II] 주식 - 11501 

<details>
	<summary>문제보기</summary>

[문제 링크](https://www.acmicpc.net/problem/11501) 

### 성능 요약

메모리: 10336 KB, 시간: 712 ms

### 분류

그리디 알고리즘

### 제출 일자

2023년 12월 16일 15:44:58

### 문제 설명

<p>홍준이는 요즘 주식에 빠져있다. 그는 미래를 내다보는 눈이 뛰어나, 날 별로 주가를 예상하고 언제나 그게 맞아떨어진다. 매일 그는 아래 세 가지 중 한 행동을 한다.</p>

<ol>
	<li>주식 하나를 산다.</li>
	<li>원하는 만큼 가지고 있는 주식을 판다.</li>
	<li>아무것도 안한다.</li>
</ol>

<p>홍준이는 미래를 예상하는 뛰어난 안목을 가졌지만, 어떻게 해야 자신이 최대 이익을 얻을 수 있는지 모른다. 따라서 당신에게 날 별로 주식의 가격을 알려주었을 때, 최대 이익이 얼마나 되는지 계산을 해달라고 부탁했다.</p>

<p>예를 들어 날 수가 3일이고 날 별로 주가가 10, 7, 6일 때, 주가가 계속 감소하므로 최대 이익은 0이 된다. 그러나 만약 날 별로 주가가 3, 5, 9일 때는 처음 두 날에 주식을 하나씩 사고, 마지막날 다 팔아 버리면 이익이 10이 된다.</p>

### 입력 

 <p>입력의 첫 줄에는 테스트케이스 수를 나타내는 자연수 T가 주어진다. 각 테스트케이스 별로 첫 줄에는 날의 수를 나타내는 자연수 N(2 ≤ N ≤ 1,000,000)이 주어지고, 둘째 줄에는 날 별 주가를 나타내는 N개의 자연수들이 공백으로 구분되어 순서대로 주어진다. 날 별 주가는 10,000이하다.</p>

### 출력 

 <p>각 테스트케이스 별로 최대 이익을 나타내는 정수 하나를 출력한다. 답은 부호있는 64bit 정수형으로 표현 가능하다.</p>

### 입력 예시
`
3   
3   
10 7 6   
3   
3 5 9   
5   
1 1 3 1 2   
`
### 출력 예시
`
0   
10   
5   
`
</details>

### 문제요약

일 별로 주식의 가격이 주어지고    
그 안에서 가장 최대 이익을 출력하는 프로그램이다.   

### 풀이과정 1

문제를 풀 때, 손해는 절대로 보면 안되니   
가격이 떨어지기 직전까지 매수하다가   
가격이 떨어지기 바로 전 날에 다 팔고   
떨어지면 다시 매수하는 꿈의 주식을 실현하면 되겠다.   

조금더 자세히 설명하자면   
날 별 주식을 배열로 생성하고   
인덱스번호를 기준으로 구매일를 0으로 저장한다.   
그리고 가격이 떨어지는 순간   
구매일로부터 그 전날까지의 이익을 계산하고   
다시 구매일를 가격이 떨어진 날로부터 설정한다.   
그리고 반복한다! 장이 끝날때까지...

#### 의사코드
```c++
void    calc_zusik(날의 수) {
    int 구매일 = 0;
    for (int i = 1; i < 날의 수; i++) {
        if (zusik[i - 1] > zusik[i]) {
            zusik[구매일] ~ zusik[i - 1] 사이의 이익 계산
            구매일 = i 로 갱신
        }
    }
    여태까지의 이익 출력
}
```

### 풀이과정 2 (문제 이해)

내가 너무 이상하게 접근을 했다.   
이러니까 내가 주식에서 돈을 잃지...   
그냥 쌀 때 사서 가장 비쌀 때 팔아버리는게 만고불변의 진리가 아닌가!   
그렇다면 내가 생각한 코드의 시나리오는 다음과 같다.   

#### 의사코드

1. 가격들을 날짜를 인덱스번호로 배열에 순서대로 넣는다.   
2. 그중 가장 큰 숫자의 인덱스번호를 구한다.
3. 해당 인덱스 번호전까지 구매를 진행한다.
4. 가장 큰 숫자에 도달시 주식을 전부 판다.
5. 다시 2번부터 4번을 주식의 끝에 도달할때까지 반복한다!

```c++
void calc_zusik(int 날짜 수) {
    int 최고가 날짜, 구매 시작일 = 0;
    최고가 날짜 = find_highest(오늘 날짜, 날짜 수);
    for (int i = 0; i < 날짜 수; i++) {
        if (i == 최고가 날짜) {
            주식 싹다 처분(구매 시작일, 오늘)
            구매시작일 = i + 1;
        }
        else if (i == 마지막 날) {
            주식 싹다 처분(구매 시작일, 오늘)
        }
    }
    최대 이익 출력
}   

```

### 풀이과정 3 (시간 초과)

100만개의 날의 수, 날 별 주가는 최대 10000   
날 별 주가는 size_t 로 처리를 했고
100만개의 날의 수를 탐색하는 과정에서   
매번 주식을 팔때마다 주식의 최대값을 찾는 완전탐색이   
시간초과를 일으키는 것 같다.
곰곰히 생각해보면 모든 주식이 10으로만 100만개로 들어오면   
매번 완전탐색을 100만 * 100만이 진행될게 아닌가?   
그러면 안되므로 같은 숫자의 경우에는 그냥 지나쳐서   
가장 뒤에있는 최대값을 고르도록 했다.

```c++
size_t	find_highest(size_t days, size_t purchased, vector<int> zusik) {
	size_t	highest = purchased;
	for (size_t i = purchased; i < days; i++) {
		if (zusik[highest] < zusik[i]) {
			highest = i;
		}
	}
	return (highest);
}
```
에서
```c++
size_t	find_highest(size_t days, size_t purchased, vector<int> zusik) {
	size_t	highest = purchased;
	for (size_t i = purchased; i < days; i++) {
		'if (zusik[highest] <= zusik[i]) {
			highest = i;
		}'
	}
	return (highest);
}
```
으로 바꿔주었다.