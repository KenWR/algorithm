# [Gold III] 중량제한 - 1939 

<details>

<summary> 문제보기 </summary>

[문제 링크](https://www.acmicpc.net/problem/1939) 

### 성능 요약

메모리: 6084 KB, 시간: 56 ms

### 분류

너비 우선 탐색, 이분 탐색, 자료 구조, 분리 집합, 그래프 이론, 그래프 탐색

### 제출 일자

2023년 11월 27일 15:16:54

### 문제 설명

<p>N(2 ≤ N ≤ 10,000)개의 섬으로 이루어진 나라가 있다. 이들 중 몇 개의 섬 사이에는 다리가 설치되어 있어서 차들이 다닐 수 있다.</p>

<p>영식 중공업에서는 두 개의 섬에 공장을 세워 두고 물품을 생산하는 일을 하고 있다. 물품을 생산하다 보면 공장에서 다른 공장으로 생산 중이던 물품을 수송해야 할 일이 생기곤 한다. 그런데 각각의 다리마다 중량제한이 있기 때문에 무턱대고 물품을 옮길 순 없다. 만약 중량제한을 초과하는 양의 물품이 다리를 지나게 되면 다리가 무너지게 된다.</p>

<p>한 번의 이동에서 옮길 수 있는 물품들의 중량의 최댓값을 구하는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄에 N, M(1 ≤ M ≤ 100,000)이 주어진다. 다음 M개의 줄에는 다리에 대한 정보를 나타내는 세 정수 A, B(1 ≤ A, B ≤ N), C(1 ≤ C ≤ 1,000,000,000)가 주어진다. 이는 A번 섬과 B번 섬 사이에 중량제한이 C인 다리가 존재한다는 의미이다. 서로 같은 두 섬 사이에 여러 개의 다리가 있을 수도 있으며, 모든 다리는 양방향이다. 마지막 줄에는 공장이 위치해 있는 섬의 번호를 나타내는 서로 다른 두 정수가 주어진다. 공장이 있는 두 섬을 연결하는 경로는 항상 존재하는 데이터만 입력으로 주어진다.</p>

### 출력 

 <p>첫째 줄에 답을 출력한다.</p>


</details>

<br>

### 풀이

A섬(A노드)에서 B섬(B노드)으로 가는 도로를 모두 지나갈 수 있는 중량의 최대값을 찾으면 된다.  

이 문제는 [이진탐색]() 문제이므로   
우선은 이진탐색의 대상이되는 변수를 정해야 하기에 중량을 변수로 잡았다.   

중량을 이진탐색의 변수로 잡고 해당 중량의 최소값과 최대값을   
주어진 도로(간선)들의 중량제한의 최소 최대치로 잡는다.   

그리고 중량의 중간값을 계속해서 목적함수에 대입해가며   
조건(A섬에서 B섬으로 갈 수 있는)에 부합한지 여부를 계속 물으며   
해당 목적함수에 대입한 중량으로 B섬에 도달 할 수 있으면 중량값을 더 늘리고   
도달 할 수 없으면 중량값을 줄이는 방식으로   
B섬에 갈 수 있는 중량과 갈 수 없는 중량의 사이를 찾으면 될 것이다.   

그리고 B섬에 도달 할 수 있는 중량들 중에서 가장 최대값을 answer라는 출력용 변수에 넣고   
마지막에 answer라는 변수를 출력하면 될 것이다.   

#### 시간복잡도

시간복잡도는 목적함수인 DFS에서는 최악의 경우 모든 섬들을 방문하며(N)  
 또 M값을 기준으로 이분탐색을 시행하니(log M)   
 시간 복잡도는 O(N log(M)) 이 된다.  

<br>

#### 고급 의사코드 #1

```c++

main() {    
    graph 이중배열을 생성해준다.   
    입력값 A, B, C를 2중배열로 넣는다.   
    예시 :   
      A B   
    A C C   
    B C C   
    만약 1, 2, 3 / 4, 5, 6 을 받으면   
      1 2 3 4 5    
    1 0 3 0 0 0   
    2 3 0 0 0 0   
    3 0 0 0 0 0   
    4 0 0 0 0 6   
    5 0 0 0 6 0   
    의 모습으로 각 좌표에 따른 중량을 요소로 뒤집어서 한번 더 넣어준다.   
    그와함께 C(중량제한)를 따로 `weight 배열`에 담아주었다.   
    (매번 연산을해서 최소, 최대값을 구하기보다 배열에 넣고 정렬하는 편이 더 빠르다고 판단했다.)   
    담은 `weight 배열`을 정렬해준다.   
    이분탐색 함수를 실행한다!
}

이분탐색 () {   
    `중량값`을 `이분탐색의 변수`로 두고   
    최소값을 `weight 배열`의 `첫번째 요소`로,   
    최대값을 `weight 배열`의 `마지막 요소`로 두고 그 중간값으로 DFS를 돌린다.   
    (입력받은 중량값 내에서 답이 나오기에 weight 배열 내의 값들로 이분탐색을 시행하면   
    중량 최대입력 값인 10억을 기준으로 두고 탐색하지 않아도 된다.)   

    도착 섬의 방문여부가 true이면 해당 중량으로 건널 수 있었으므로   
    현재 중량과 최대중량의 중간값으로 다시 DFS 탐색을하고
    false인 경우에는 중량을 줄여야 하므로 현재 중량과 최소 중량의 중간으로 다시 DFS탐색을 하며   
    true로 나온 중량이 여태 나온 중량중에 가장 크다면 중량을 따로 `answer` 변수에 넣어준다.   

    위의 행위를 최대, 최소 중량값이 서로 역전되기 전까지 반복을 하고, `answer`변수를 출력한다.
}

DFS (시작 섬(노드), 중량) {
    섬의 방문 여부에 대한 bool 배열에 `시작 섬` 의 방문여부를 true로 변경해준다.   

    시작 섬을 이중배열에서의 x축으로 기준을 두고 y축을 전부 탐색하며   
    해당 요소가 중량값보다 크거나 같을때,   
    시작섬을 해당 요소의 y축을 시작섬으로 두어 재귀를 돌린다.
}

```

<br>

#### 저급 의사코드 #2

```c++

main() {
    for () {
        for () {
            graph 만들기...
            reverse graph 만들기...
            weight 배열에 C 삽입
        }
    }
    A, B섬 입력받기
    sort(weight);
}

이분탐색() {
    low = 0, high = M - 1;
    while (low <= start) {
        섬 방문여부 초기화
        중간값 = (low + high) / 2;
        DFS(A, weight[중간값]);
        if (B섬 방문여부 == true) {
            low = 중간값;
            if (중간값 > answer) {
                answer = 중간값;
            }
        }
        else {
            high = 중간값;
        }
    }
    출력 answer;
}

DFS(섬, 중량 (==중간값)) {
    섬 방문여부 = true;
    for (시작섬의 y축 순회...) {
        if ((섬, y) >= 중량) {
            DFS(y, 중량);
        }
    }
}


```

### 오답노트

<details>
<summary>메모리 초과</summary>

최대 10,000개의 섬이 주어지는데 이것을 이중배열 graph로 만들어버리면 10000 * 10000 즉, 100000000 1억이라는 크기의 배열이 vector로 늘어나 버리면 힙 영역이 초과되면서 메모리 초과가 뜨고 말았다.

```c++

for (int i = 0; i < M; i++) {
		std::cin >> A >> B >> C;
		islands[A][B] = C;
		islands[B][A] = C;
		weights.push_back(C);
	}

```

에서

```c++

for (int i = 0; i < M; i++) {
		std::cin >> A >> B >> C;
		islands[A].push_back(std::make_pair(B, C));
		islands[B].push_back(std::make_pair(A, C));
		weights.push_back(C);
	}

```

로 pair 라는 컨테이너를 이용해 pair 의 두번째요소에 C를 넣음으로써 마치 이중배열처럼 작동하도록 했다.

</details>

### 리팩토링

```


```