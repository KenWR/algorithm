각 기준이 되는 좌표는 색종이의 좌측 왼쪽으로 잡았다.
즉 예제에서 분할하지 않은 색종이의 기준은 (0, 0) 이고
N / 2 로 분할한 색종이의 기준은
(0, 0), (0, 4), (4, 0), (4, 4) 가 된다.
위의 이론으로 문제를 풀어보자면

색종이를 이중배열에 bool type 으로 1 == BLUE, 0 == WHITE 로 상정했다.
해당 기준에 있는 색을 우선 미리 저장한다. (now_color)
그러므로 반복 문을 2번돌려 완전탐색을 통해 색종이 색들을 now_color와 비교하다가
맞지않는 색을 만날경우 바로 분할탐색을 한다.
해당 부분을 재귀로 풀기로했다.

재귀(x좌표, y좌표, 탐색범위) {
    현재 구하는 색종이의 색 = 색종이[x][y];
    조건 (한칸짜리 색종이가 아닌데 홀수에서 기준이 시작되었다면) {
        함수종료 ;
    }
    조건 (탐색범위가 1일때는 필요가 없으니 1보다 클때만 아래의 코드를 실행한다)
        반복 (x 좌표에서 탐색범위 전까지) {
            반복 (y 좌표에서 탐색범위 전까지) {
                조건 (색종이[x + 0~탐색범위 전까지][y + 0~탐색범위 전까지] 가 now_color와 같지 않다면) {
                    조건에 맞게 재귀를 N / 2 로 4번을 돌린다
                    현재 함수에서는 색종이가 없으니 종료
                }
            }
        }
    }
    위의 조건에 부합하면
    현재 색종이의 색에 따라 해당 색의 count 를 늘려준다.
}