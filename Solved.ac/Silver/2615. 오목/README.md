# [Silver I] 오목 - 2615 
<details>
    <summary>문제보기</summary>
[문제 링크](https://www.acmicpc.net/problem/2615) 

### 성능 요약

메모리: 2020 KB, 시간: 0 ms

### 분류

브루트포스 알고리즘, 구현

### 제출 일자

2023년 12월 10일 12:52:13

### 문제 설명

<p>오목은 바둑판에 검은 바둑알과 흰 바둑알을 교대로 놓아서 겨루는 게임이다. 바둑판에는 19개의 가로줄과 19개의 세로줄이 그려져 있는데 가로줄은 위에서부터 아래로 1번, 2번, ... ,19번의 번호가 붙고 세로줄은 왼쪽에서부터 오른쪽으로 1번, 2번, ... 19번의 번호가 붙는다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/42c87203-247a-49d1-bc63-44397a7184db/-/preview/" style="width: 274px; height: 303px;"></p>

<p>위의 그림에서와 같이 같은 색의 바둑알이 연속적으로 다섯 알을 놓이면 그 색이 이기게 된다. 여기서 연속적이란 가로, 세로 또는 대각선 방향 모두를 뜻한다. 즉, 위의 그림은 검은색이 이긴 경우이다. 하지만 여섯 알 이상이 연속적으로 놓인 경우에는 이긴 것이 아니다.</p>

<p>입력으로 바둑판의 어떤 상태가 주어졌을 때, 검은색이 이겼는지, 흰색이 이겼는지 또는 아직 승부가 결정되지 않았는지를 판단하는 프로그램을 작성하시오. 단, 검은색과 흰색이 동시에 이기거나 검은색 또는 흰색이 두 군데 이상에서 동시에 이기는 경우는 입력으로 들어오지 않는다.</p>

### 입력 

 <p>19줄에 각 줄마다 19개의 숫자로 표현되는데, 검은 바둑알은 1, 흰 바둑알은 2, 알이 놓이지 않는 자리는 0으로 표시되며, 숫자는 한 칸씩 띄어서 표시된다.</p>

#### 예제

0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 1 2 0 0 2 2 2 1 0 0 0 0 0 0 0 0 0 0
0 0 1 2 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0
0 0 0 1 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 1 2 2 0 0 0 0 0 0 0 0 0 0 0 0
0 0 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 2 1 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

### 출력 

 <p>첫줄에 검은색이 이겼을 경우에는 1을, 흰색이 이겼을 경우에는 2를, 아직 승부가 결정되지 않았을 경우에는 0을 출력한다. 검은색 또는 흰색이 이겼을 경우에는 둘째 줄에 연속된 다섯 개의 바둑알 중에서 가장 왼쪽에 있는 바둑알(연속된 다섯 개의 바둑알이 세로로 놓인 경우, 그 중 가장 위에 있는 것)의 가로줄 번호와, 세로줄 번호를 순서대로 출력한다.</p>

#### 예제

1
3 2

</details>

### 풀이과정

19 * 19 의 이중배열로 오목판이 주어지고   
각 배열의 요소에 0 == 없음 1 == 흑 2 == 백의 형태로   
값이 주어지는게 입력값이다.   

오목판을 생성해 입력값들로 채워주고, 
오목판을 완전탐색하면서 돌을 발견할때마다 8방향으로   
쭉 5번 퍼져나가는데 반대편까지 살펴봐야한다.   
그렇게 길이를 구해 해당 길이가 5가 된다면,   
오목으로 판단하고 가장 왼쪽위에 있는 돌의 좌표를   
구해서 출력하면 되겠다.   

애초에 탐색을 왼쪽 위부터 진행하기에   
지나간 부분을 확인할 필요가 없다고 판단하여   
오른쪽부터 아래 대각 왼쪽부분까지 아래 4방향만 탐색하기로했다.   

```
보드판을 채워 넣고,   

해당 보드판을 행, 열의 순서로 탐색을 진행하다가,   
돌을 발견하면 해당돌이 오목인지 확인한다.  

오목을 찾으면 출력   
```

#### 오류 1

6목인데 만약 2번째 줄부터 시작을 해버리면   
오목이 나와버리는 문제가 발생했다.   

### 문제풀이 2

위의 문제풀이 1에서 오목을 탐색하는 부분을 다르게 진행했다.   
오목을 찾을때 양쪽 반대편을 탐색하도록 했으며   
탐색했을시 (/ \ - |) 4방향으로 나뉘어 탐색을 진행하고   
각 방향에서 매개변수로주어진 돌의 색과 다르면 반복을 종료했다.   
그렇게 돌의 길이를 계산하여 오목임을 확인하면   
또 다시 오목의 왼쪽, 수직의 경우 위쪽을 찾기위해 탐색하는   
오목의 머리를 구하는 함수를 작성하여 머리부분을 출력한다.   

#### 시간 계산

`(19 * 19)` * `(25 * 4)` 로    
`완전탐색할 오목판 전체 크기`와 `대각선을 포함한 오목 방향`을   
보수적으로 구해 4000번이 되겠다.

```c++
void    set_board() {
    입력값을 보드 배열에 넣기
}

void    search_all() {
    완전탐색으로 보드판 전부 흝기
    돌 발견하면 좌표와 돌 색을 매개변수로
    if (오목찾기(y, x, 색)) { // 오목이 맞으면
        오목_머리구하기 (y, x, 색, 오목찾기(y, x, 색))
        return;
    }
}

int    find_omok(int y, int x, int color) {
    int len = 0;

    if (/ 를 구하는 함수 == 5)
        return 1
        .
        .
        .
    \ 를 구하는 함수
        return 2
    - 를 구하는 함수
        return 3
    | 를 구하는 함수
        return 4

    return 0;
}

void    오목_머리구하기(int y, int x, int color, int flag) {
    flag에 맞게 오목 머리 구하고
    color\n 오목 머리의 y, x 좌표 + 1씩해서 출력
}
```
