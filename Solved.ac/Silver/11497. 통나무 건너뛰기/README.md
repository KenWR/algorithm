# [Silver I] 통나무 건너뛰기 - 11497 

<details>
    <summary>문제</summary>

[문제 링크](https://www.acmicpc.net/problem/11497) 

### 성능 요약

메모리: 2336 KB, 시간: 60 ms

### 분류

그리디 알고리즘, 정렬

### 제출 일자

2023년 12월 17일 18:57:27

### 문제 설명

<p>남규는 통나무를 세워 놓고 건너뛰기를 좋아한다. 그래서 N개의 통나무를 원형으로 세워 놓고 뛰어놀려고 한다. 남규는 원형으로 인접한 옆 통나무로 건너뛰는데, 이때 각 인접한 통나무의 높이 차가 최소가 되게 하려 한다.</p>

<p style="text-align:center"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11497/1.png" style="height:268px; width:274px"></p>

<p>통나무 건너뛰기의 난이도는 인접한 두 통나무 간의 높이의 차의 최댓값으로 결정된다. 높이가 {2, 4, 5, 7, 9}인 통나무들을 세우려 한다고 가정하자. 이를 [2, 9, 7, 4, 5]의 순서로 세웠다면, 가장 첫 통나무와 가장 마지막 통나무 역시 인접해 있다. 즉, 높이가 2인 것과 높이가 5인 것도 서로 인접해 있다. 배열 [2, 9, 7, 4, 5]의 난이도는 |2-9| = 7이다. 우리는 더 나은 배열 [2, 5, 9, 7, 4]를 만들 수 있으며 이 배열의 난이도는 |5-9| = 4이다. 이 배열보다 난이도가 낮은 배열은 만들 수 없으므로 이 배열이 남규가 찾는 답이 된다.</p>

### 입력 

 <p>입력은 T개의 테스트 케이스로 이루어져 있다. 첫 줄에 T가 주어진다.</p>

<p>이어지는 각 줄마다 첫 줄에 통나무의 개수를 나타내는 정수 N(5 ≤ N ≤ 10,000), 둘째 줄에 각 통나무의 높이를 나타내는 정수 L<sub>i</sub>가 주어진다. (1 ≤ L<sub>i</sub> ≤ 100,000)</p>

### 출력 

 <p>각 테스트 케이스마다 한 줄에 주어진 통나무들로 만들 수 있는 최소 난이도를 출력하시오.</p>

### 입력 예시
```
3
7
13 10 12 11 10 11 12
5
2 4 5 7 9
8
6 6 6 6 6 6 6 6
```
### 출력 예시
```
1
4
0
```

</details>

### 문제요약

원형으로 둘러 쌓인 통나무들로 만들 수 있는 최소 난이도를 구하는 프로그램을 작성하라.

### 풀이과정 1
 
배열로 통나무를 늘어뜨려놓고   
어떻게든 조합을 바꿔가며 완전탐색을 통해   
최소 난이도를 구하려고 했으나 시간복잡도가   
문제에서 주어진 1초를 초과할 수 밖에없었다.   

그래서 이 문제는 내가 모르는   
어떠한 수학적 방법이 있다고 판단하여    
검색을 해서 방법을 찾게 되었다.   

내가 찾은 방법은 [정규 분포]()를 이용해 문제를 푸는 방법이다.   

간단하게 가장 큰 수를 가운데에 두고   
양쪽을 적은 수로 채워넣는것이다.   
vector 로 삽입을 계속해도   
통나무의 개수는 1만개가 최대이므로   
O(n^log(n)^) 으로 1초를 넘기지 않을 것이다.

#### 의사코드
1. 우선 통나무를 배열로 받아 sort 한다.
2. 새로운 배열에 가장 큰 수를 넣는다.
3. 새로운 배열에 큰 수 부터 앞, 뒤 번갈아가며 넣는다.

```c++
flag = false
sort(통나무)
새로운 배열에 가장 큰 통나무추가
for (int i = 통나무 개수 - 2; i >= 0; i--) {
    if (flag == false) {
        새로운 배열 앞에 통나무[i] 추가
        flag = true;
    }
    else {
        새로운 배열 뒤에 통나무[i] 추가
        flag = false;
    }
}
배열간에 가장 큰 차이를 완전탐색으로 구하고   
가장 큰 값을 출력한다.
```