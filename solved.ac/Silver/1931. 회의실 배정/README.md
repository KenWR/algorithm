1. [문제](#silver-i-회의실-배정---1931)
2. [입 & 출력](#입력)
3. [문제 요약](#문제요약)
4. [풀이](#풀이과정)
    1. [의사코드](#의사코드-1)
    2. [시간복잡도](#시간-복잡도-1)
5. [오류수정 1](#오류-수정-1-시간-초과)
    1. [의사코드](#의사코드-2)
6. [오류수정 2](#오류-수정-2-시간초과)
    1. [의사코드](#의사코드-3)


# [Silver I] 회의실 배정 - 1931 

[문제 링크](https://www.acmicpc.net/problem/1931) 

### 성능 요약

메모리: 3688 KB, 시간: 28 ms

### 분류

그리디 알고리즘, 정렬

### 제출 일자

2023년 12월 18일 13:35:39

### 문제 설명

<p>한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하여 회의실 사용표를 만들려고 한다. 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자. 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다. 회의의 시작시간과 끝나는 시간이 같을 수도 있다. 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다.</p>

### [입력] 

 <p>첫째 줄에 회의의 수 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N+1 줄까지 각 회의의 정보가 주어지는데 이것은 공백을 사이에 두고 회의의 시작시간과 끝나는 시간이 주어진다. 시작 시간과 끝나는 시간은 2<sup>31</sup>-1보다 작거나 같은 자연수 또는 0이다.</p>

### 출력 

 <p>첫째 줄에 최대 사용할 수 있는 회의의 최대 개수를 출력한다.</p>

### 입력 예시
```
11
1 4
3 5
0 6
5 7
3 8
5 9
6 10
8 11
8 12
2 13
12 14
```
### 출력 예시
```
4
```

### [문제요약]

시작시간과 끝나는 시간이 주어지는 회의 시간들을   
겹치지 않게 최대한 많은 회의를 할 수 있도록   
시간표를 작성하고 회의의 개수를 출력하는 프로그램을 작성하라.

1. 회의 시간은 최대값이 int의 최대값과 같다.
2. 0이 포함된다.
3. 회의의 수는 최대 10만개다.
4. 회의 시작과 끝시간이 같을수도 있다.
5. 두 회의중 먼저있는 회의의 끝시간과 뒤에있는 회의의 시작시간이 같을 수 있다.

### [풀이과정]

각 회의 정보의 회의 시간을 따로 구하고   
가장 적은 회의시간을 가진 회의로만 시간표를 만들면 되겠다.   
또, 회의가 당장 바로 잡지 않고 조금 쉬어가더라도   
한 두시간 이상 뒤에 잡았을 때가 더 많은 회의가 가능하다면   
그렇게 할 수 있도록 해야한다.

#### [의사코드 1]
1. pair 형식으로 <시작 시간, 끝 시간> 으로 배열에 저장한다.
2. 회의시간, 시작시간 순서로 오름차순 정렬한다.
    - 이렇게하면 각 시작시간별로 회의시간이 정렬된다.
3. 변수 회의개수 = 0, base시간, 최소 시간을 선언한다.
4. 배열을 인덱스번호로 탐색한다.
5. 첫번째 요소를 기준으로 잡고 따로 저장한다.
8. 인덱스를 증가 시키면서 각 요소를 저장한 값과 비교를 한다.
    - 비교를 했을때 끝 시간이 더 적으면 변수에 값을 대입하고 따로 저장한다.
9. (시작시간 < 저장된 요소의 끝 시간) 까지 탐색한다.
10. 회의개수 + 1 해준다.
11. 인덱스 - 1(시작시간 == 정해진 회의 끝 시간) 부터 4 ~ 10을 반복한다.

```c++
void	scheduling(int 총회의개수) {
	int	회의개수 = 0;
	pair<int, int> 회의정보;
	
	for (int i = 0; i < 총회의개수; i++) {
		회의정보 = 회의정보배열[i];
		while (끝까지 가거나 시작시간 < 저장된 요소의 끝 시간 까지) {
			if (저장된 회의정보보다 끝시간이 적으면)
				회의정보 = 회의정보배열[i];
			i++;
		}
		회의개수++;
		i--;
	}
	회의개수 출력;
}
```

#### [시간 복잡도 1]

이렇게되면 모든 회의 정보의 회의 시작과 끝시간이 같을 경우 까지 계산해도 O(N) 이 된다.

### [오류 수정 1 (시간 초과)]

시간 초과가 일어나기에   
sort를 2번하는 과정에서 문제가 생긴다고 판단해   
sort 함수를 최적화를 통해 O(2N)에서 O(N)으로 줄였다.   
그리고 [const 참조](https://github.com/KenWR/personal-study/blob/main/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%20%26%20%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%97%90%EB%8C%80%ED%95%9C%20%EA%B3%A0%EC%B0%B0/%EC%83%81%EC%88%98%20%EC%B0%B8%EC%A1%B0(const%20T%26)%20feat.%EC%B5%9C%EC%A0%81%ED%99%94.md)를 통해 최적화를 진행했다.

#### [의사코드 2]
```c++
	sort(meet_info.begin(), meet_info.end(), ascending_sec);
	sort(meet_info.begin(), meet_info.end(), ascending_fir);

int	ascending_fir(pair<int, int> a, pair<int, int> b) {
	return (a.first < b.first);
}


int	ascending_sec(pair<int, int> a, pair<int, int> b) {
	return (a.second < b.second);
}
```
에서
```c++
	sort(meet_info.begin(), meet_info.end(), ascending_sec);
	sort(meet_info.begin(), meet_info.end(), ascending_fir);

bool	ascending_fir(const pair<int, int> &a, const pair<int, int> &b) {
    if (a.first == b.first)
        return (a.second < b.second);
	return (a.first < b.first);
}
```
으로
### [오류 수정 2 (시간초과)]

그리고 그 결과... 82% 에서 났던 시간초과가   
85%를 간신히 넘기더니 다시 시간초과가 났다.   

그렇다면 회의시간을 비교하는 scheduling 함수내에서   
2중 반복문에 분기가 여러개가 들어가는 부분을 줄였다.

#### [의사코드 3]
1. for 문 안에코드를 다 지우고
2. 처음 시작하는 회의정보배열[i]의 회의 시작시간이   
    현재 회의정보의 끝시간보다 크거나 같으면   
    회의정보를 저장하고 회의개수를 증가시킨다
3. 회의정보배열[i] 의 끝시간보다   
    저장된 회의정보 끝시간이 더 크다면   
    회의정보를 회의정보배열[i]로 갱신시킨다.   

```c++
void	scheduling(int 총회의개수) {
	int	회의개수 = 0;
	pair<int, int> 회의정보;
	
	for (int i = 0; i < 총회의개수; i++) {
		if (회의정보배열[i].first >= 회의정보.second) {
			회의정보 = 회의정보배열[i];
			회의개수++;
		}
		if (회의정보배열[i].second < 회의정보.second) {
			회의정보 = 회의정보배열[i];
		}
	}
	회의개수 출력;
}
```
이렇게 분기들을 줄였더니 아주 빠르게 정답을 얻어냈다.