1. [문제](#silver-i-스티커---9465)
2. [입 & 출력](#입력)
3. [분석](#분석)
4. [풀이(오답)](#풀이(오답))
    1. [설계](#설계)
    2. [오답코드](#오답코드)
5. [수정](#수정)
    1. [설계](#설계--2)
6. [시간복잡도](#시간-복잡도)
7. [사용 알고리즘](#사용-알고리즘)

# [Silver I] 스티커 - 9465 

[문제 링크](https://www.acmicpc.net/problem/9465) 

### 성능 요약

메모리: 2800 KB, 시간: 84 ms

### 분류

다이나믹 프로그래밍

### 제출 일자

2023년 12월 27일 16:30:28

### 문제 설명

<p>상근이의 여동생 상냥이는 문방구에서 스티커 2n개를 구매했다. 스티커는 그림 (a)와 같이 2행 n열로 배치되어 있다. 상냥이는 스티커를 이용해 책상을 꾸미려고 한다.</p>

<p>상냥이가 구매한 스티커의 품질은 매우 좋지 않다. 스티커 한 장을 떼면, 그 스티커와 변을 공유하는 스티커는 모두 찢어져서 사용할 수 없게 된다. 즉, 뗀 스티커의 왼쪽, 오른쪽, 위, 아래에 있는 스티커는 사용할 수 없게 된다.</p>

<p><img alt="" src="https://www.acmicpc.net/upload/images/sticker.png" style="height:150px; width:575px"></p>

<p>모든 스티커를 붙일 수 없게된 상냥이는 각 스티커에 점수를 매기고, 점수의 합이 최대가 되게 스티커를 떼어내려고 한다. 먼저, 그림 (b)와 같이 각 스티커에 점수를 매겼다. 상냥이가 뗄 수 있는 스티커의 점수의 최댓값을 구하는 프로그램을 작성하시오. 즉, 2n개의 스티커 중에서 점수의 합이 최대가 되면서 서로 변을 공유 하지 않는 스티커 집합을 구해야 한다.</p>

<p>위의 그림의 경우에 점수가 50, 50, 100, 60인 스티커를 고르면, 점수는 260이 되고 이 것이 최대 점수이다. 가장 높은 점수를 가지는 두 스티커 (100과 70)은 변을 공유하기 때문에, 동시에 뗄 수 없다.</p>

### [입력] 

 <p>첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스의 첫째 줄에는 n (1 ≤ n ≤ 100,000)이 주어진다. 다음 두 줄에는 n개의 정수가 주어지며, 각 정수는 그 위치에 해당하는 스티커의 점수이다. 연속하는 두 정수 사이에는 빈 칸이 하나 있다. 점수는 0보다 크거나 같고, 100보다 작거나 같은 정수이다. </p>

### 출력 

 <p>각 테스트 케이스 마다, 2n개의 스티커 중에서 두 변을 공유하지 않는 스티커 점수의 최댓값을 출력한다.</p>

### 입력 예시

```
2
5
50 10 100 20 40
30 50 70 10 60
7
10 30 10 50 100 20 40
20 40 30 50 60 20 80
```

### 출력 예시

```
260
290
```

### [분석]

십자로 겹치지 않게 최대한 많은 점수를 모아   
그 합을 출력하는 문제다.   

두 줄로 최대 100,000개가 입력으로 들어오니   
배열로 값을 전부 받을 수 없다.   

스티커의 점수는 최대 100점이니   
100000 * 100 으로 int형 범위를 넘지 않는다.   

### [풀이(오답)]

문제의 예제에 풀이가 다 나와있는듯 하다.   
처음엔 대각선으로 값을 받아와야 하지만   
뒤에 어떤 값이 들어오는지 당장은 알 수 없기에   
또한 미리 값을 받아 확인할 수도 없기 때문에   
그대로 연산을 해야한다.   
   
마침 연산의 가짓수는   
1. 위부터 시작해서 대각선으로   
2. 아래부터 시작해서 대각선으로   

딱 이 두가지밖에 없으니   
두 가지의 합을 구하고 예제에서 나온 것 처럼   
마지막 3개중 가장 큰 합을 구하면 되겠다.   

합을 구하는데 한줄씩밖에 값이 들어오지 않으니   
한 칸 씩 띄어서 연산을 해 놓으면 되겠다.   

#### [설계] 
1. 값을 계속 받아오면서
    위, 아래부터 대각선의 합을 구하다가   
    3개가 남으면 배열에 저장한다.   
2. 위, 아래의 기준에서 3개를 연산해 더한다.   
3. 합을 출력한다.   

```c++
n개만큼 2번 입력값 받기 {
    위시작 += 입력값
    아래시작 += 입력값
    
    3개남으면 이차원 배열에 위, 아래 기준으로 저장
}
남은 3개 연산하기
둘중 가장 큰 값 출력
```

#### [오답코드]

<details>
    <summary>오답코드</summary>

```c++
	#include <algorithm>
	#include <iostream>
	using namespace std;

	int tail_start, head_start;

	void	calc_score(int n);

	int	main() {
		int T, n;

		ios::sync_with_stdio(false);
		cin.tie(nullptr);
		cout.tie(nullptr);

		cin >> T;
		while (T--> 0) {
			// n개만큼 2번 입력값
			cin >> n;
			calc_score(n);
			cout << max(tail_start, head_start) << '\n';
		}
	}

	void	calc_score(int n) {
		int	tmp, idx_t = 0, idx_h = 0, twice = 2,\
		up_tail = 0, up_head = 0, down_tail = 0, down_head = 0,\
		lefttail[4] = {0, }, lefthead[4] = {0, };
		
		while (twice-- > 0) {
			for (int i = 0; i < n; i++) {
				cin >> tmp;
				// 꼬리에서 4개 남길때
				// 한줄기준 2개가 남으면 배열에 삽입
				if (i >= n - 2)
					lefttail[idx_t++] = tmp;
				// 0 나머지연산 없애기 + 2번째 시작시 홀수 짝수 바꾸기
				else if ((i + twice) % 2 == 1)
					up_tail += tmp;
				else if ((i + twice) % 2 == 0)
					down_tail += tmp;

				// 머리에서 4개 남길때
				// 한줄기준 2개가 남으면 배열에 삽입
				if (i <= 1) 
					lefthead[idx_h++] = tmp;
				// 0 나머지연산 없애기 + 2번째 시작시 홀수 짝수 바꾸기
				else if ((i + twice) % 2 == 1)
					up_head += tmp;
				else if ((i + twice) % 2 == 0)
					down_head += tmp;
			}
		}
		// 3개 연산

		// 꼬리 나머지일때
		// 짝수줄이 주어질때
		if (n % 2 == 0) {
			up_tail += max(lefttail[0] + lefttail[3], lefttail[2]);
			down_tail += max(lefttail[1] + lefttail[2], lefttail[3]);
		}
		// // 홀수줄이 주어질때
		else if (n % 2 == 1) {
			up_tail += max(lefttail[1] + lefttail[2], lefttail[3]);
			down_tail += max(lefttail[0] + lefttail[3], lefttail[2]);
		}

		// 머리 나머지일때
		up_head += max(lefthead[0] + lefthead[3], lefthead[2]);
		down_head += max(lefthead[1] + lefthead[2], lefthead[0]);

		tail_start = max(up_tail, down_tail);
		head_start = max(up_head, down_head);
	}
```

</details>

#### [수정]

- 한줄만으로 모든 상황에 대한 연산이 불가능 하다.

꼬리만이 아닌 모든 경우에서 두칸을 건너 뛸 상황이 생긴다.   
```
10 10 100 10  100 10 10
10 10 10  100 10  10 10
```
이라는 값이 들어오게되면   
위 아래 어디에서 시작을 하던 중간에 100을 고르는 것이   
가장 큰 수를 얻을 수 있게 될 것이다.   

그렇다면 어떻게 연산을 해야   
뒤에 영향이 가지 않게 최대합을 구할까?   
시작은 똑같이 
1. 위부터 시작을 하는가      
2. 아래로 시작을 하는가   

로 나뉜다.

Dynamic Programming을 통해 문제를 풀어나갈 것 이기에   
연산을 최소화 하고 이미 한 연산의 답을 다시 재활용 해야한다.   

우리가 건너뛸 수 있는 최대인 두 칸 내에서   
그전에 구한 합 중 최대의 크기를 선택하면 된다.   
그리고 그 합과 현재의 숫자를 더한 값을 그 자리에 넣으면 된다.   

처음부터 시작해서 해당 숫자까지의 최대 합을   
계속해서 선택하다보면 맨 마지막에 나오는 수는 결국   
최대 합이 나올 것이다.   

공식을 쓰기전에 눈으로 조금 보자면
```
현재 위치 == ..
..
50 10 100 20 40
30 50 70  10 60

   ..
50 40 100 20 40
30 100 70 10 60

       ..
50 40  200 20 40
30 100 120 10 60

           ..
50 40  200 140 40
30 100 120 210 60

               ..
50 40  200 140 250
30 100 120 210 260
```

이런식으로 3번째 위치를 배열로 설명을 하자면
스티커[0][2]의 값을 구하는 법은   
`max(스티커[0][0] + 스티커[1][1], 스티커[1][0]) + 스티커[0][2]`   
로 볼 수 있다.   

하지만 `max(스티커[0][0] + 스티커[1][1], 스티커[1][0])` 이 부분의   
연산을 처음부터 끝까지 할 필요 없이 매번 그 합을 해당 위치에 저장하면   
그 값이 곧, 그 위치까지의 최대 합이 되는 것이다.   

그렇다면 우리는 스티커[0][2]를 구하기 위해서는   
`max(스티커[1][0], 스티커[1][1]) + 스티커[0][2]`   
가 되는 것이다.   

공식은 다음과 같다.
```c++
스티커[0][i] = max(스티커[1][i - 2], 스티커[1][i - 1]) + 스티커[0][i];
스티커[1][i] = max(스티커[0][i - 2], 스티커[0][i - 1]) + 스티커[1][i];
```
    
결국 연산이 위, 아래줄을 왔다갔다 하기때문에    
미리 아래줄까지 받아와야 할 것이다.   
그렇기에 배열을 미리선언해 받는것이 좋겠다.   

#### [설계 -2]
1. arr[2][100005] 로 조금 넉넉하게 배열을 2개 선언한다.   
2. 배열의 [0][0], [1][0]에 0을 넣고 후에 입력값을 삽입한다.   
3. 삽입한 배열을 2 ~ n 까지 공식을 돌린다.
4. arr[0][n] 과 arr[1][n] 중 가장 큰 값을 출력한다.

```c++
int arr[2][100005];

arr[0][0] = 0;
arr[1][0] = 0;
for (i = 0 ~ 1 까지) {
    for (j = 1 ~ n 까지) 
        arr[i][j] = 입력값;
}
for (i = 2 ~ n 까지)
    공식
출력 max(arr[0][n], arr[1][n]);
```

#### [시간 복잡도]

1. T번 케이스 반복
2. 초기화는 O(1)
3. 최대합 계산 O(n)

O(T * n)

### [사용 알고리즘]

Dynamic Programming
    Tabulation

### [후기]

너무 힘들었다...   
공식 찾는게 끔찍하게 힘들었다....   