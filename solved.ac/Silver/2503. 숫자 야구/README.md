# [Silver III] 숫자 야구 - 2503 

<details>
	<summary>문제보기</summary>

[문제 링크](https://www.acmicpc.net/problem/2503) 

### 성능 요약

메모리: 2020 KB, 시간: 0 ms

### 분류

브루트포스 알고리즘, 구현

### 제출 일자

2023년 12월 9일 15:47:15

### 문제 설명

<p>정보문화진흥원 정보 영재 동아리에서 동아리 활동을 하던 영수와 민혁이는 쉬는 시간을 틈타 숫자야구 게임을 하기로 했다.</p>

<ul>
	<li>영수는 1에서 9까지의 서로 다른 숫자 세 개로 구성된 세 자리 수를 마음속으로 생각한다. (예: 324)</li>
	<li>민혁이는 1에서 9까지의 서로 다른 숫자 세 개로 구성된 세 자리 수를 영수에게 묻는다. (예: 123)</li>
	<li>민혁이가 말한 세 자리 수에 있는 숫자들 중 하나가 영수의 세 자리 수의 동일한 자리에 위치하면 스트라이크 한 번으로 센다. 숫자가 영수의 세 자리 수에 있긴 하나 다른 자리에 위치하면 볼 한 번으로 센다.</li>
</ul>

<p>예) 영수가 324를 갖고 있으면 </p>

<ul>
	<li>429는 1 스트라이크 1 볼이다.</li>
	<li>241은 0 스트라이크 2 볼이다.</li>
	<li>924는 2 스트라이크 0 볼이다.</li>
	<li>영수는 민혁이가 말한 수가 몇 스트라이크 몇 볼인지를 답해준다.</li>
	<li>민혁이가 영수의 세 자리 수를 정확하게 맞추어 3 스트라이크가 되면 게임이 끝난다. 아니라면 민혁이는 새로운 수를 생각해 다시 영수에게 묻는다.</li>
</ul>

<p>현재 민혁이와 영수는 게임을 하고 있는 도중에 있다. 민혁이가 영수에게 어떤 수들을 물어보았는지, 그리고 각각의 물음에 영수가 어떤 대답을 했는지가 입력으로 주어진다. 이 입력을 바탕으로 여러분은 영수가 생각하고 있을 가능성이 있는 수가 총 몇 개인지를 알아맞혀야 한다.</p>

<p>아래와 같은 경우를 생각해보자.  </p>

<ul>
	<li>민혁: 123</li>
	<li>영수: 1 스트라이크 1 볼.</li>
	<li>민혁: 356</li>
	<li>영수: 1 스트라이크 0 볼.</li>
	<li>민혁: 327</li>
	<li>영수: 2 스트라이크 0 볼.</li>
	<li>민혁: 489</li>
	<li>영수: 0 스트라이크 1 볼.</li>
</ul>

<p>이때 가능한 답은 324와 328, 이렇게 두 가지이다.</p>

<p>영수는 동아리의 규율을 잘 따르는 착한 아이라 민혁이의 물음에 곧이곧대로 정직하게 답한다. 그러므로 영수의 답들에는 모순이 없다.</p>

<p>민혁이의 물음들과 각각의 물음에 대한 영수의 답이 입력으로 주어질 때 영수가 생각하고 있을 가능성이 있는 답의 총 개수를 출력하는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄에는 민혁이가 영수에게 몇 번이나 질문을 했는지를 나타내는 1 이상 100 이하의 자연수 N이 주어진다. 이어지는 N개의 줄에는 각 줄마다 민혁이가 질문한 세 자리 수와 영수가 답한 스트라이크 개수를 나타내는 정수와 볼의 개수를 나타내는 정수, 이렇게 총 세 개의 정수가 빈칸을 사이에 두고 주어진다.</p>

### 출력 

 <p>첫 줄에 영수가 생각하고 있을 가능성이 있는 답의 총 개수를 출력한다.</p>

</details>

### 풀이과정

#### 풀이방식 1

strike 일때 적어도 그 자릿수에서 해당하는 숫자의 확률이 오르고,   
ball 일때 그 자릿수를 제외한 다른 자릿수에서의   
해당 숫자의 확률이 오른다고 판단해,   

3자릿수를 1 ~ 9 로 나열한 3 * 9 배열을 선언해
각 자릿수의 확률이 오를 때마다 + strike / ball씩 계산을 했다.   

- 수행시간

연산 시간으로는 1초에 1억번을 기준으로
N * 3 * 9,   
N이 최대값이 100이므로   
문제에서 주어진 시간제한을 넘을일은 없어보였다.

#### 오류발생

문제에 나온 예제에서 32* 까지는 정상적으로 출력 되었으나,   
그 뒤에 324, 328이 답이므로 4와 8이 가장 큰 확률을 가지고 있어야 하는데,   
엉뚱한 숫자인 7이 가장 높은 확률로 들어있는 걸 확인할 수 있었다.   

입/출력 :   
```
입력
4
123 1 1
356 1 0
327 2 0
489 0 1
출력
0 1 4 -1 0 0 0 1 1 
1 2 1 1 1 0 0 -1 1 
1 1 0 1 0 1 2 1 -1 
```

#### 풀이방식 2

위의 해결방식으로는 푸는게 힘들다고 판단하였고,   
int 000 ~ 999 까지의 3자릿수 1000개의 배열을 선언해,   
true 값으로 초기화 시키고,   
받은 3자릿수를 인덱스값으로 같은 숫자가 나오는 것만 피해서     
숫자를 받을때마다 인덱스값과 비교하여 같이 입력된 strike 와 ball 이   
일치하는 모든 3자릿수들을 인덱스값으로 배열의 요소를 + 1 해주면,   
정답으로 나올 수 있는 모든 3자릿수를 인덱스로 하는 배열의 요소 값은   
N과 같아질 것이라고 판단하였고,   
N과 같은 값을 가진 자릿수들의 합을 출력하도록 한다.

인덱스 값을 만드는데 있어서 123 ~ 999 까지 무작정 높이면서   
각 자릿수를 계산하며 중복값을 제거하는 것 보다는   
3중 for 문을 통해서 같은 숫자일때 건너뛰는 것이 가독성이 더 좋으면서,   
strike, ball 을 계산할때 더욱 편해지고,   
예외처리를 통해 연산속도도 더 빨라질것이라 판단했다.

- 수행시간

연산 시간은 1초에 1억번을 기준으로   
N * 1000   
N의 최대값이 100이므로 1000000, 10만으로 시간제한에 걸리지 않는다.

- 의사코드   
```c++
배열[1000] 을 선언한다.

while (N 만큼) {

    숫자, 스트라이크, 볼을 입력 받는다.

    3중 포문 {
        123 ~ 999 까지의 임의의 숫자를 중복을 제외한 범위 내에서,   
        임의의 숫자가 주어진 숫자와 비교를 진행해       
        스트라이크와 볼의 수를 찾는다.

        스트라이크와 볼의 수가 일치하는 임의의 숫자를 인덱스번호를 삼아,   
        배열[임의의 숫자]++;   
    }

}

다시 배열을 순회하며 N값과 같은 요소들의 합 을 출력

```

#### 풀이방식(리팩토링)
완전탐색이긴하나 진짜진짜 비효율적이라 좀더 괜찮은 방법을 찾아냈다.   
`풀이방식 2`에서 입력된 3자릿수에 123 ~ 999 까지 모든 수를 대입했는데,   
대입을 매번해서 각 자릿수를 인덱스로 하는 배열의 요소 == N   
을 구하는 것이 아닌, 주어진 3자릿수를 만족하는 친구들을 따로   
배열이나 queue에 담아 그 다음 입력된 3자릿수와 비교를 하는식으로,   
좀더 최적화가 이루어 질 수 있겠다.   

그리고... 3중 for문이 생각보다 너무 가독성이 별로라서 바꿨다.
