x, y좌표에서 2 * 2 사이즈의 사각형이 되어 최소한의 'Z'를 그릴 때까지 재귀를 돌렸다.   
그리고 각 움직일만큼의 길이인 limit이라는 변수의 값이 2가 되는 순간, 'Z'를 그리면서 count 를 + 1 씩 해주고 해당 좌표에 x, y좌표가 도달하였을때, count 값을 출력시켜 해당 좌표가 몇번째로 방문했는지 출력하도록 했다.   
출력은 정상으로 나왔으나 시간초과가 발생하였는데 cpu에서의 연산이 1억번에 1초라고 가정을 했을때, 2^15 * 2^15 == 1073741824 로 10초의 연산시간을 가지게된다.
실제로 time.h 의 헤더를 사용해 밀리초까지 재봤을때 9초 내외의 속도가 나왔다.  
그렇다면 불필요한 연산을 하지 않기위해서는 불필요한 재귀를 없앨 필요가 있었다.
방법은 단순하다.
재귀를 돌릴때 분리한 4개의 좌표범위 안에 찾고자 하는 범위가 존재하는 부분만 재귀를 돌게하고 돌지 않는 다른 부분의 count += 범위 * 범위의 값으로 더해주기만 하고 해당 최소 크기의 'Z' 내에 찾고자하는 좌표가 들어갔을때 간단히 'Z'를 그리며 count++ 를 해주고 해당 좌표에 도달하였을때 count값을 출력하도록 하였다.
그랬더니 연산속도가 모든 경우에 대해 0.0002 ms로 통일되어 문제에서 요하는 최소 시간인 0.5초를 초과하지 않을 수 있었다.