1. [문제](#silver-i-정수-삼각형---1932)
2. [입 & 출력](#입력)
3. [분석](#분석)
4. [풀이](#풀이)
    1. [의사코드](#의사코드-1)
    2. [시간복잡도](#시간-복잡도)
5. [사용 알고리즘](#사용-알고리즘)
6. [후기](#후기)

# [Silver I] 정수 삼각형 - 1932 

[문제 링크](https://www.acmicpc.net/problem/1932) 

### 성능 요약

메모리: 2024 KB, 시간: 8 ms

### 분류

다이나믹 프로그래밍

### 제출 일자

2023년 12월 24일 18:57:54

### 문제 설명

<pre>        7
      3   8
    8   1   0
  2   7   4   4
4   5   2   6   5</pre>

<p>위 그림은 크기가 5인 정수 삼각형의 한 모습이다.</p>

<p>맨 위층 7부터 시작해서 아래에 있는 수 중 하나를 선택하여 아래층으로 내려올 때, 이제까지 선택된 수의 합이 최대가 되는 경로를 구하는 프로그램을 작성하라. 아래층에 있는 수는 현재 층에서 선택된 수의 대각선 왼쪽 또는 대각선 오른쪽에 있는 것 중에서만 선택할 수 있다.</p>

<p>삼각형의 크기는 1 이상 500 이하이다. 삼각형을 이루고 있는 각 수는 모두 정수이며, 범위는 0 이상 9999 이하이다.</p>

### [입력] 

 <p>첫째 줄에 삼각형의 크기 n(1 ≤ n ≤ 500)이 주어지고, 둘째 줄부터 n+1번째 줄까지 정수 삼각형이 주어진다.</p>

### 출력 

 <p>첫째 줄에 합이 최대가 되는 경로에 있는 수의 합을 출력한다.</p>

### 입력 예시

```
5
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5
```

### 출력 예시

```
30
```

### [분석]

정삼각형에서 바로 양 옆 아래에 있는 경로만으로 이동했을때   
최대로 나올 수 있는 합을 구하라

### [풀이]

```
        7
      3   8
    8   1   0
  2   7   4   4
4   5   2   6   5
```
이런식으로 값이 주어졌을 때   
애초에 값들을 더해버리면 되지 않나 싶었다.   
더할때 중복이 되면 그중 가장 큰 수를 더하면 되겠다.   

```
           7
        10   15
     18    16   15
   20   25   20    19
24    30   27   26    24   
```
이렇게 말이다.   

배열을 선언하고   
7넣고   
10 받으면 17로   
15는 새로 22로   

```
{7} + 3, 8
    ||
{10, 15} + 8, 1, 0
    ||
{18, 16, 15} + 2, 7, 4, 4
    ||
{20, 25, 20, 19} + 4, 5, 2, 6, 5
    ||
{24, 30, 27, 26, 24}
```

이런식으로 만들면 되겠다.   

최대 숫자는 9999까지 삼각형은 500개까지   
전부 더해봐야 결국 10000 * 500 으로 5만개가 최대   
int형으로 충분하다.   

#### [의사코드 1]
1. 505사이즈의 배열을 2개 선언한다.   
    합, 더하기 배열   
    (vector는 좀 느릴것 같음)   
2. 첫 줄을 더하기 배열에 넣는다.   
3. 더하기 배열의 인덱스 != 처음, != 끝 이라면   
    합 배열의 인덱스 - 1, 인덱스 값에 접근해 가장 큰수와 결합  
4. 더하기 배열의 인덱스 == 처음, == 끝 이라면
    처음일경우 더하기 배열의 자신과 같은 인덱스와 결합
    끝일경우 더하기 배열의 자신보다 -1작은 인덱스와 결합
5. 더하기 배열을 합 배열에 복사해 넣는다.
6. 2 ~ 5를 N번만큼 반복한다.
7. 합 배열을 순회하며 그중 가장 큰 수를 출력

```c++
각 줄마다 {
    한 줄씩 더하기 배열에 저장

    합 배열과 더하기 배열 비교 {
        더하기 배열 인덱스 != 처음, != 끝
            합 배열 인덱스 - 1, 인덱스 중 큰 수와 결합
        더하기 배열 인덱스 == 처음 일 때
            인덱스 그대로 합배열과 결합
        더하기 배열 인덱스 == 끝 일 때
            합 배열 인덱스 - 1과 결합
    }
    더하기가 끝난 더하기 배열 합 배열에 복사
}
합 배열 순회하며 그중 가장 큰 수 출력

```

#### [시간 복잡도]

외부함수 O(N) * 내부함수 O(N)   
O(N^2^)   

### [사용 알고리즘]

Dynamic Programming
    Tabulation

### [후기]

개인적으로 쉽게 풀었다.   
여태 푼 문제들 중에서 가장 빨리 푼것 같다.   
문제 읽고 푸는데 10분도 채 걸리지 않은것 같다.   
전에 다이나믹 프로그래밍 문제를 푼게   
아주 큰 도움이 되었다.   