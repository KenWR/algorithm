N 종류의 아이스크림,   
M은 섞어먹으면 안되는 조합의 개수
그리고 M만큼
섞으면 안되는 조합들이 나온다.   

같은조합, (2, 3), (3, 2) 는 1개로 취급한다.
아이스크림은 3개이상 합치지 않고 딱 2개만 합친다.

윤정이는 아이스크림을 3가지 선택하려고하는데   
맛없는 조합을 회피하려고한다.   

5종류의 아이스크림, 3가지, 섞으면 안되는 조합
그러면 완전탐색을 3중포문을 5번씩 돌리면 되겠다.
조합 나올때마다 count 증가   

여기서 조건이 있다.   
1. 자체 중복
    (1, 1, 1) 이거나 (1, 2, 3) , (3, 1, 2)
2. 섞으면 안되는 조합

두 조건중 하나라도 부합하면 count는 증가하지 않는다.

코드가 많이 더러워지는데 좀 줄일순 없을까?
그리고 애초에 3개나되는 조합을 어떻게 저장을 해놓지?

일단 풀어보자

적어도 3개의 조합을 저장하는데
아이스크림이 최대 200개일때 
중복을 제외한 가짓수는 1313400개
(n! / ((n - m)! * m!))
배열 선언을 못한다. 너무 크다.

그냥 저장할 필요없이 
식으로 계산하자

N! / ((N - 3)! * 6);
에서 1, 2 / 3, 4 / 1, 3 이 주어졌으면
각자 N - 2 값이 가짓수로 맛없는 조합이 완성된다.
그러면 총 9개인데 1, 2 와 1, 3에서 중복이 발생한다.
그렇다면 중복을 처리해주는 로직만 찾으면 되겠다.

위의 로직은 N 값이 200일때 오버플로우가 일어나버린다.

그러면 그냥 전체 가짓수를 구하고 3! 값을 나누도록해야겠다.

왜 3! 이냐고? 3개를 고를때 거기서 나오는 중복값이 6개이기때문이다.

3중 for문으로 가짓수들을 정하고
그안에 맛없는 조합들을 위한 반복문을 넣어서 
4중 for문으로 돌려야겠다.

이렇게 하니까 log(N^3^ * M) 이 되버려서 시간초과가 나버린다.

그렇다면 그냥 전체 가짓수를 브루트포스로 구하고 
거기서 중복값을 빼는식으로 해야겠다.

중복값 빼는식을 못구하겠다...

그냥 N * N 의 이중배열을 bool 타입으로 선언하고
맛없는 조합이나오면 해당 조합과 뒤집은 조합으로
해당 좌표에 true값을 넣어주고
3중 for문에서 비교해가면서 count를 증가해줬다.