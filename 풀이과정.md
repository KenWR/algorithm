1. [문제]()
2. [입 & 출력](#입력)
3. [분석](#분석)
4. [풀이](#풀이)
    1. [설계](#설계)
5. [오답노트](#오답노트)
    1. [오답코드](#오답코드)
    2. [풀이]
    2. [설계](#설계--2)
6. [시간복잡도](#시간-복잡도)
7. [사용 알고리즘](#사용-알고리즘)

### 입력 예시
1
```
7
3 10
5 20
1 10
1 20
2 15
4 40
2 200
```
2
```
10
1 1
1 2
1 3
1 4
1 5
1 6
1 7
1 8
1 9
1 10
```
3
```
10
5 10
5 9
5 8
5 7
5 6
5 10
5 9
5 8
5 7
5 6
```
4
```
10
5 50
4 40
3 30
2 20
1 10
1 10
2 20
3 30
4 40
5 50
```

### 출력 예시
1
```
45
```
2
```
55
```
3
```
20
```
4
```
90
```

### [분석]

- 스케쥴링 문제의 DP버전으로 겹치지 않는 시간내에서   
    최대한의 금전적 이익을 내고 그 합을 출력하라

1. 문제의 메모리 제한은 512MB 로 (15 * 2)만개의 배열을 선언하기에 아주 넉넉하다.   
2. 금액은 최대 1000으로 15만 * 1000 은 최대 15억으로 int형을 벗어나지 않는다.   

### [풀이]

<details>
    <summary>끄적이기</summary>

```
0  1  2  3  4  5  6  7  8  9  시작일
5  4  3  2  1  1  2  3  4  5  일
50 40 30 20 10 10 20 30 40 50 금액

arr[일 / 금액][n]
끝나는날 = i + arr[0][i];

5  5  5  5  5  6  8  10 12 14  끝나는 날짜
0  1  2  3  4  5  6  7  8  9   시작 날짜
50 40 30 20 10 10 20 30 40 50




i + 1까지 연산 가능

0 + 5 + 7 == 50 + 10 + 30 = 90

시작날짜 중복 x
끝나는 날짜 중복 o

정렬하고
끝나는 날짜들 중 시작 날짜가 가장 큰것
중첩되는 부분 패스

정렬을하기에는 크기가 너무 큼
300만개를 정렬하면 
introsort를 쓰는 c++ 에서 O(N log(N))으로
선형탐색까지 더해주면 일단 1초는 사라지게된다.

전체적으로 못해도 O(N log(N))이 나오도록 설계해야한다.


```

</details>

#### [설계(틀림)] 



### [오답노트]

- 

#### [틀린코드] 

#### [풀이 -2]

#### [설계 -2]

```c++

```

#### [시간 복잡도]

### [사용 알고리즘]


### [후기]

