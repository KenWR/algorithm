1. [문제]()
2. [입 & 출력](#입력)
3. [분석](#분석)
4. [풀이](#풀이)
    1. [설계](#설계)
    2. [틀린코드](#틀린코드)
5. [오류](#오류)
    1. [설계](#설계--2)
6. [시간복잡도](#시간-복잡도)
7. [사용 알고리즘](#사용-알고리즘)

### 입력 예시

```
2
5
50 10 100 20 40
30 50 70 10 60
7
10 30 10 50 100 20 40
20 40 30 50 60 20 80
```

### 출력 예시

```
260
290
```

### [분석]

십자로 겹치지 않게 최대한 많은 점수를 모아   
그 합을 출력하는 문제다.   

두 줄로 최대 100,000개가 입력으로 들어오니   
배열로 값을 전부 받을 수 없다.   

스티커의 점수는 최대 100점이니   
100000 * 100 으로 int형 범위를 넘지 않는다.   

### [풀이]

문제의 예제에 풀이가 다 나와있는듯 하다.   
처음엔 대각선으로 값을 받아와야 하지만   
뒤에 어떤 값이 들어오는지 당장은 알 수 없기에   
또한 미리 값을 받아 확인할 수도 없기 때문에   
그대로 연산을 해야한다.   
   
마침 연산의 가짓수는   
1. 위부터 시작해서 대각선으로   
2. 아래부터 시작해서 대각선으로   

딱 이 두가지밖에 없으니   
두 가지의 합을 구하고 예제에서 나온 것 처럼   
마지막 3개중 가장 큰 합을 구하면 되겠다.   

합을 구하는데 한줄씩밖에 값이 들어오지 않으니   
한 칸 씩 띄어서 연산을 해 놓으면 되겠다.   

#### [설계] 
1. 값을 계속 받아오면서
    위, 아래부터 대각선의 합을 구하다가   
    3개가 남으면 배열에 저장한다.   
2. 위, 아래의 기준에서 3개를 연산해 더한다.   
3. 합을 출력한다.   

```c++
n개만큼 2번 입력값 받기 {
    위시작 += 입력값
    아래시작 += 입력값
    
    3개남으면 이차원 배열에 위, 아래 기준으로 저장
}
남은 3개 연산하기
둘중 가장 큰 값 출력
```

#### [틀린코드]

<details>
    <summary>틀린코드</summary>

```c++
	#include <algorithm>
	#include <iostream>
	using namespace std;

	int tail_start, head_start;

	void	calc_score(int n);

	int	main() {
		int T, n;

		ios::sync_with_stdio(false);
		cin.tie(nullptr);
		cout.tie(nullptr);

		cin >> T;
		while (T--> 0) {
			// n개만큼 2번 입력값
			cin >> n;
			calc_score(n);
			cout << max(tail_start, head_start) << '\n';
		}
	}

	void	calc_score(int n) {
		int	tmp, idx_t = 0, idx_h = 0, twice = 2,\
		up_tail = 0, up_head = 0, down_tail = 0, down_head = 0,\
		lefttail[4] = {0, }, lefthead[4] = {0, };
		
		while (twice-- > 0) {
			for (int i = 0; i < n; i++) {
				cin >> tmp;
				// 꼬리에서 4개 남길때
				// 한줄기준 2개가 남으면 배열에 삽입
				if (i >= n - 2)
					lefttail[idx_t++] = tmp;
				// 0 나머지연산 없애기 + 2번째 시작시 홀수 짝수 바꾸기
				else if ((i + twice) % 2 == 1)
					up_tail += tmp;
				else if ((i + twice) % 2 == 0)
					down_tail += tmp;

				// 머리에서 4개 남길때
				// 한줄기준 2개가 남으면 배열에 삽입
				if (i <= 1) 
					lefthead[idx_h++] = tmp;
				// 0 나머지연산 없애기 + 2번째 시작시 홀수 짝수 바꾸기
				else if ((i + twice) % 2 == 1)
					up_head += tmp;
				else if ((i + twice) % 2 == 0)
					down_head += tmp;
			}
		}
		// 3개 연산

		// 꼬리 나머지일때
		// 짝수줄이 주어질때
		if (n % 2 == 0) {
			up_tail += max(lefttail[0] + lefttail[3], lefttail[2]);
			down_tail += max(lefttail[1] + lefttail[2], lefttail[3]);
		}
		// // 홀수줄이 주어질때
		else if (n % 2 == 1) {
			up_tail += max(lefttail[1] + lefttail[2], lefttail[3]);
			down_tail += max(lefttail[0] + lefttail[3], lefttail[2]);
		}

		// 머리 나머지일때
		up_head += max(lefthead[0] + lefthead[3], lefthead[2]);
		down_head += max(lefthead[1] + lefthead[2], lefthead[0]);

		tail_start = max(up_tail, down_tail);
		head_start = max(up_head, down_head);
	}
```

</details>

#### [오류]

- 한줄만으로 모든 상황에 대한 연산이 불가능 하다.

꼬리만이 아닌 모든 경우에서 두칸을 건너 뛸 상황이 생긴다.   
```
10 10 100 10  100 10 10
10 10 10  100 10  10 10
```
이라는 값이 들어오게되면   
위 아래 어디에서 시작을 하던 중간에 100을 고르는 것이   
가장 큰 수를 얻을 수 있게 될 것이다.   

그렇다면 어떻게 연산을 해야   
뒤에 영향이 가지 않게 최대합을 구할까?   
시작은 똑같이 
1. 위부터 시작을 하는가      
2. 아래로 시작을 하는가   

로 나뉜다.

Dynamic Programming을 통해 문제를 풀어나갈 것 이기에   
연산을 최소화 하고 이미 한 연산의 답을 다시 재활용 해야한다.   

우리가 건너뛸 수 있는 최대인 두 칸 내에서   
그전에 구한 합 중 최대의 크기를 선택하면 된다.   
그리고 그 합과 현재의 숫자를 더한 값을 그 자리에 넣으면 된다.   

처음부터 시작해서 해당 숫자까지의 최대 합을   
계속해서 선택하다보면 맨 마지막에 나오는 수는 결국   
최대 합이 나올 것이다.   

공식을 쓰기전에 눈으로 조금 보자면
```
현재 위치 == ..
..
50 10 100 20 40
30 50 70  10 60

   ..
50 40 100 20 40
30 100 70 10 60

       ..
50 40  200 20 40
30 100 120 10 60

           ..
50 40  200 140 40
30 100 120 210 60

               ..
50 40  200 140 250
30 100 120 210 260
```

이런식으로 3번째 위치를 배열로 설명을 하자면
스티커[0][2]의 값을 구하는 법은   
`max(스티커[0][0] + 스티커[1][1], 스티커[1][0]) + 스티커[0][2]`   
로 볼 수 있다.   

하지만 `max(스티커[0][0] + 스티커[1][1], 스티커[1][0])` 이 부분의   
연산을 처음부터 끝까지 할 필요 없이 매번 그 합을 해당 위치에 저장하면   
그 값이 곧, 그 위치까지의 최대 합이 되는 것이다.   

그렇다면 우리는 스티커[0][2]를 구하기 위해서는   
`max(스티커[1][0], 스티커[1][1]) + 스티커[0][2]`   
가 되는 것이다.   

공식은 다음과 같다.
```c++
스티커[0][i] = max(스티커[1][i - 2], 스티커[1][i - 1]) + 스티커[0][i];
스티커[1][i] = max(스티커[0][i - 2], 스티커[0][i - 1]) + 스티커[1][i];
```
    
결국 연산이 위, 아래줄을 왔다갔다 하기때문에    
미리 아래줄까지 받아와야 할 것이다.   
그렇기에 배열을 미리선언해 받는것이 좋겠다.   

#### [설계 -2]
1. arr[2][100005] 로 조금 넉넉하게 배열을 2개 선언한다.   
2. 배열의 [0][0], [1][0]에 0을 넣고 후에 입력값을 삽입한다.   
3. 삽입한 배열을 2 ~ n 까지 공식을 돌린다.
4. arr[0][n] 과 arr[1][n] 중 가장 큰 값을 출력한다.

```c++
int arr[2][100005];

arr[0][0] = 0;
arr[1][0] = 0;
for (i = 0 ~ 1 까지) {
    for (j = 1 ~ n 까지) 
        arr[i][j] = 입력값;
}
for (i = 2 ~ n 까지)
    공식
출력 max(arr[0][n], arr[1][n]);
```

#### [시간 복잡도]

### [사용 알고리즘]


### [후기]

