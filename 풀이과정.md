### 입력 예시
```
11
1 4
3 5
0 6
5 7
3 8
5 9
6 10
8 11
8 12
2 13
12 14
```
### 출력 예시
```
4
```
### 문제요약

시작시간과 끝나는 시간이 주어지는 회의 시간들을   
겹치지 않게 최대한 많은 회의를 할 수 있도록   
시간표를 작성하고 회의의 개수를 출력하는 프로그램을 작성하라.

1. 회의 시간은 최대값이 int의 최대값과 같다.
2. 0이 포함된다.
3. 회의의 수는 최대 10만개다.
4. 회의 시작과 끝시간이 같을수도 있다.
5. 두 회의중 먼저있는 회의의 끝시간과 뒤에있는 회의의 시작시간이 같을 수 있다.

### 풀이과정

각 회의 정보의 회의 시간을 따로 구하고   
가장 적은 회의시간을 가진 회의로만 시간표를 만들면 되겠다.   
또, 회의가 당장 바로 잡지 않고 조금 쉬어가더라도   
한 두시간 이상 뒤에 잡았을 때가 더 많은 회의가 가능하다면   
그렇게 할 수 있도록 해야한다.

#### 의사코드
1. pair 형식으로 <시작 시간, 끝 시간> 으로 배열에 저장한다.
2. 회의시간, 시작시간 순서로 오름차순 정렬한다.
    - 이렇게하면 각 시작시간별로 회의시간이 정렬된다.
3. 변수 회의개수 = 0, base시간, 최소 시간을 선언한다.
4. 배열을 인덱스번호로 탐색한다.
5. 첫번째 요소를 기준으로 잡고 따로 저장한다.
8. 인덱스를 증가 시키면서 각 요소를 저장한 값과 비교를 한다.
    - 비교를 했을때 끝 시간이 더 적으면 변수에 값을 대입하고 따로 저장한다.
9. (시작시간 < 저장된 요소의 끝 시간) 까지 탐색한다.
10. 회의개수 + 1 해준다.
11. 인덱스 - 1(시작시간 == 정해진 회의 끝 시간) 부터 4 ~ 10을 반복한다.

```c++
void	scheduling(int 총회의개수) {
	int	회의개수 = 0;
	pair<int, int> 회의정보;
	
	for (int i = 0; i < 총회의개수; i++) {
		회의정보 = 회의정보배열[i];
		while (끝까지 가거나 시작시간 < 저장된 요소의 끝 시간 까지) {
			if (저장된 회의정보보다 끝시간이 적으면)
				회의정보 = 회의정보배열[i];
			i++;
		}
		회의개수++;
		i--;
	}
	회의개수 출력;
}
```

#### 시간 복잡도

이렇게되면 모든 회의 정보의 회의 시작과 끝시간이 같을 경우 까지 계산해도 O(N) 이 된다.

### 오류 수정 (시간 초과)

시간 초과가 일어나기에   
sort를 2번하는 과정에서 문제가 생긴다고 판단해   
sort 함수를 최적화를 통해 O(2N)에서 O(N)으로 줄였다.   
그리고 [const 참조](https://github.com/KenWR/personal-study/blob/main/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%20%26%20%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%97%90%EB%8C%80%ED%95%9C%20%EA%B3%A0%EC%B0%B0/%EC%83%81%EC%88%98%20%EC%B0%B8%EC%A1%B0(const%20T%26)%20feat.%EC%B5%9C%EC%A0%81%ED%99%94.md)를 통해 최적화를 진행했다.
```c++
	sort(meet_info.begin(), meet_info.end(), ascending_sec);
	sort(meet_info.begin(), meet_info.end(), ascending_fir);

int	ascending_fir(pair<int, int> a, pair<int, int> b) {
	return (a.first < b.first);
}


int	ascending_sec(pair<int, int> a, pair<int, int> b) {
	return (a.second < b.second);
}
```
에서
```c++
	sort(meet_info.begin(), meet_info.end(), ascending_sec);
	sort(meet_info.begin(), meet_info.end(), ascending_fir);

bool	ascending_fir(const pair<int, int> &a, const pair<int, int> &b) {
    if (a.first == b.first)
        return (a.second < b.second);
	return (a.first < b.first);
}
```
으로
### 오류 수정 2 (시간초과)

그리고 그 결과... 82% 에서 났던 시간초과가   
85%를 간신히 넘기더니 다시 시간초과가 났다.   

그렇다면 회의시간을 비교하는 scheduling 함수내에서   
2중 반복문에 분기가 여러개가 들어가는 부분을 줄였다.

#### 의사코드
1. for 문 안에코드를 다 지우고
2. 처음 시작하는 회의정보배열[i]의 회의 시작시간이   
    현재 회의정보의 끝시간보다 크거나 같으면   
    회의정보를 저장하고 회의개수를 증가시킨다
3. 회의정보배열[i] 의 끝시간보다   
    저장된 회의정보 끝시간이 더 크다면   
    회의정보를 회의정보배열[i]로 갱신시킨다.   

```c++
void	scheduling(int 총회의개수) {
	int	회의개수 = 0;
	pair<int, int> 회의정보;
	
	for (int i = 0; i < 총회의개수; i++) {
		if (회의정보배열[i].first >= 회의정보.second) {
			회의정보 = 회의정보배열[i];
			회의개수++;
		}
		if (회의정보배열[i].second < 회의정보.second) {
			회의정보 = 회의정보배열[i];
		}
	}
	회의개수 출력;
}
```
이렇게 분기들을 줄였더니 아주 빠르게 정답을 얻어냈다.