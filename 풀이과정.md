1. [문제](#silver-i-회의실-배정---1931)
2. [입 & 출력](#입력)
3. [분석](#분석)
4. [풀이](#풀이과정)
    1. [의사코드](#의사코드-1)
    2. [시간복잡도](#시간-복잡도)
5. [사용 알고리즘](#사용-알고리즘)

### 입력 예시

```
5
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5
```

### 출력 예시

```
30
```

### [분석]

정삼각형에서 바로 양 옆 아래에 있는 경로만으로 이동했을때   
최대로 나올 수 있는 합을 구하라

### [풀이]

```
        7
      3   8
    8   1   0
  2   7   4   4
4   5   2   6   5
```
이런식으로 값이 주어졌을 때   
애초에 값들을 더해버리면 되지 않나 싶었다.   
더할때 중복이 되면 그중 가장 큰 수를 더하면 되겠다.   

```
           7
        10   15
     18    16   15
   20   25   20    19
24    30   27   26    24   
```
이렇게 말이다.   

배열을 선언하고   
7넣고   
10 받으면 17로   
15는 새로 22로   

```
{7} + 3, 8
    ||
{10, 15} + 8, 1, 0
    ||
{18, 16, 15} + 2, 7, 4, 4
    ||
{20, 25, 20, 19} + 4, 5, 2, 6, 5
    ||
{24, 30, 27, 26, 24}
```

이런식으로 만들면 되겠다.   

최대 숫자는 9999까지 삼각형은 500개까지   
전부 더해봐야 결국 10000 * 500 으로 5만개가 최대   
int형으로 충분하다.   

#### [의사코드 1]
1. 505사이즈의 배열을 2개 선언한다.   
    합, 더하기 배열   
    (vector는 좀 느릴것 같음)   
2. 첫 줄을 더하기 배열에 넣는다.   
3. 더하기 배열의 인덱스 != 처음, != 끝 이라면   
    합 배열의 인덱스 - 1, 인덱스 값에 접근해 가장 큰수와 결합  
4. 더하기 배열의 인덱스 == 처음, == 끝 이라면
    처음일경우 더하기 배열의 자신과 같은 인덱스와 결합
    끝일경우 더하기 배열의 자신보다 -1작은 인덱스와 결합
5. 더하기 배열을 합 배열에 복사해 넣는다.
6. 2 ~ 5를 N번만큼 반복한다.
7. 합 배열을 순회하며 그중 가장 큰 수를 출력

```c++
각 줄마다 {
    한 줄씩 더하기 배열에 저장

    합 배열과 더하기 배열 비교 {
        더하기 배열 인덱스 != 처음, != 끝
            합 배열 인덱스 - 1, 인덱스 중 큰 수와 결합
        더하기 배열 인덱스 == 처음 일 때
            인덱스 그대로 합배열과 결합
        더하기 배열 인덱스 == 끝 일 때
            합 배열 인덱스 - 1과 결합
    }
    더하기가 끝난 더하기 배열 합 배열에 복사
}
합 배열 순회하며 그중 가장 큰 수 출력

```

#### [시간 복잡도]

외부함수 O(N) * 내부함수 O(N)   
O(N^2^)   

### [사용 알고리즘]

Dynamic Programming
    Tabulation

### [후기]

개인적으로 쉽게 풀었다.   
여태 푼 문제들 중에서 가장 빨리 푼것 같다.   
문제 읽고 푸는데 10분도 채 걸리지 않은것 같다.   
전에 다이나믹 프로그래밍 문제를 푼게   
아주 큰 도움이 되었다.   